{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global global */\n\n\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nvar isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText =\n/* CSS */\n'\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.' + className + ':empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn\\'t support \\'-webkit-text-fill-color\\'\\n    * So we use \\'color: transparent\\' to make the text transparent on IE\\n    * Unlike other browsers, it doesn\\'t affect caret color in IE\\n    */\\n  .' + className + ' {\\n    color: transparent !important;\\n  }\\n\\n  .' + className + '::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n';\n\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n\n  function Editor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Editor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      capture: true\n    }, _this._recordCurrentState = function () {\n      var input = _this._input;\n      if (!input) return; // Save current state of the input\n\n      var value = input.value,\n          selectionStart = input.selectionStart,\n          selectionEnd = input.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      });\n    }, _this._getLines = function (text, position) {\n      return text.substring(0, position).split('\\n');\n    }, _this._recordChange = function (record) {\n      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$_history = _this._history,\n          stack = _this$_history.stack,\n          offset = _this$_history.offset;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        _this._history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100\n\n        var count = _this._history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          var extras = count - HISTORY_LIMIT;\n          _this._history.stack = stack.slice(extras, count);\n          _this._history.offset = Math.max(_this._history.offset - extras, 0);\n        }\n      }\n\n      var timestamp = Date.now();\n\n      if (overwrite) {\n        var last = _this._history.stack[_this._history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n          // Match the last word in the line\n          var re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line\n\n          var previous = _this._getLines(last.value, last.selectionStart).pop().match(re); // Get the current line\n\n\n          var current = _this._getLines(record.value, record.selectionStart).pop().match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            _this._history.stack[_this._history.offset] = _extends({}, record, {\n              timestamp: timestamp\n            });\n            return;\n          }\n        }\n      } // Add the new operation to the stack\n\n\n      _this._history.stack.push(_extends({}, record, {\n        timestamp: timestamp\n      }));\n\n      _this._history.offset++;\n    }, _this._updateInput = function (record) {\n      var input = _this._input;\n      if (!input) return; // Update values and selection state\n\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      _this.props.onValueChange(record.value);\n    }, _this._applyEdits = function (record) {\n      // Save last selection state\n      var input = _this._input;\n      var last = _this._history.stack[_this._history.offset];\n\n      if (last && input) {\n        _this._history.stack[_this._history.offset] = _extends({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      } // Save the changes\n\n\n      _this._recordChange(record);\n\n      _this._updateInput(record);\n    }, _this._undoEdit = function () {\n      var _this$_history2 = _this._history,\n          stack = _this$_history2.stack,\n          offset = _this$_history2.offset; // Get the previous edit\n\n      var record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.max(offset - 1, 0);\n      }\n    }, _this._redoEdit = function () {\n      var _this$_history3 = _this._history,\n          stack = _this$_history3.stack,\n          offset = _this$_history3.offset; // Get the next edit\n\n      var record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    }, _this._handleKeyDown = function (e) {\n      var _this$props = _this.props,\n          tabSize = _this$props.tabSize,\n          insertSpaces = _this$props.insertSpaces,\n          ignoreTabKey = _this$props.ignoreTabKey,\n          onKeyDown = _this$props.onKeyDown;\n\n      if (onKeyDown) {\n        onKeyDown(e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n      }\n\n      var _e$target = e.target,\n          value = _e$target.value,\n          selectionStart = _e$target.selectionStart,\n          selectionEnd = _e$target.selectionEnd;\n      var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && _this.state.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          var linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var startLine = linesBeforeCaret.length - 1;\n          var endLine = _this._getLines(value, selectionEnd).length - 1;\n          var nextValue = value.split('\\n').map(function (line, i) {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          }).join('\\n');\n\n          if (value !== nextValue) {\n            var startLineText = linesBeforeCaret[startLine];\n\n            _this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          var _linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var _startLine = _linesBeforeCaret.length - 1;\n\n          var _endLine = _this._getLines(value, selectionEnd).length - 1;\n\n          var _startLineText = _linesBeforeCaret[_startLine];\n\n          _this._applyEdits({\n            value: value.split('\\n').map(function (line, i) {\n              if (i >= _startLine && i <= _endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            }).join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)\n          });\n        } else {\n          var updatedSelection = selectionStart + tabCharacter.length;\n\n          _this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        var hasSelection = selectionStart !== selectionEnd;\n        var textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          var _updatedSelection = selectionStart - tabCharacter.length;\n\n          _this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: _updatedSelection,\n            selectionEnd: _updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          var line = _this._getLines(value, selectionStart).pop();\n\n          var matches = line.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault(); // Preserve indentation on inserting a new line\n\n            var indent = '\\n' + matches[0];\n\n            var _updatedSelection2 = selectionStart + indent.length;\n\n            _this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: _updatedSelection2,\n              selectionEnd: _updatedSelection2\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        var chars = void 0;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        } // If text is selected, wrap them in the characters\n\n\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          _this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ? // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z : // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n\n        _this._undoEdit();\n      } else if ((isMacLike ? // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y : // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n\n        _this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault(); // Toggle capturing tab key so users can focus away\n\n        _this.setState(function (state) {\n          return {\n            capture: !state.capture\n          };\n        });\n      }\n    }, _this._handleChange = function (e) {\n      var _e$target2 = e.target,\n          value = _e$target2.value,\n          selectionStart = _e$target2.selectionStart,\n          selectionEnd = _e$target2.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      }, true);\n\n      _this.props.onValueChange(value);\n    }, _this._history = {\n      stack: [],\n      offset: -1\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Editor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._recordCurrentState();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          value = _props.value,\n          style = _props.style,\n          padding = _props.padding,\n          highlight = _props.highlight,\n          textareaId = _props.textareaId,\n          textareaClassName = _props.textareaClassName,\n          autoFocus = _props.autoFocus,\n          disabled = _props.disabled,\n          form = _props.form,\n          maxLength = _props.maxLength,\n          minLength = _props.minLength,\n          name = _props.name,\n          placeholder = _props.placeholder,\n          readOnly = _props.readOnly,\n          required = _props.required,\n          onClick = _props.onClick,\n          onFocus = _props.onFocus,\n          onBlur = _props.onBlur,\n          onKeyUp = _props.onKeyUp,\n          onKeyDown = _props.onKeyDown,\n          onValueChange = _props.onValueChange,\n          tabSize = _props.tabSize,\n          insertSpaces = _props.insertSpaces,\n          ignoreTabKey = _props.ignoreTabKey,\n          preClassName = _props.preClassName,\n          rest = _objectWithoutProperties(_props, ['value', 'style', 'padding', 'highlight', 'textareaId', 'textareaClassName', 'autoFocus', 'disabled', 'form', 'maxLength', 'minLength', 'name', 'placeholder', 'readOnly', 'required', 'onClick', 'onFocus', 'onBlur', 'onKeyUp', 'onKeyDown', 'onValueChange', 'tabSize', 'insertSpaces', 'ignoreTabKey', 'preClassName']);\n\n      var contentStyle = {\n        paddingTop: padding,\n        paddingRight: padding,\n        paddingBottom: padding,\n        paddingLeft: padding\n      };\n      var highlighted = highlight(value);\n      return React.createElement('div', _extends({}, rest, {\n        style: _extends({}, styles.container, style)\n      }), React.createElement('textarea', {\n        ref: function ref(c) {\n          return _this2._input = c;\n        },\n        style: _extends({}, styles.editor, styles.textarea, contentStyle),\n        className: className + (textareaClassName ? ' ' + textareaClassName : ''),\n        id: textareaId,\n        value: value,\n        onChange: this._handleChange,\n        onKeyDown: this._handleKeyDown,\n        onClick: onClick,\n        onKeyUp: onKeyUp,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        disabled: disabled,\n        form: form,\n        maxLength: maxLength,\n        minLength: minLength,\n        name: name,\n        placeholder: placeholder,\n        readOnly: readOnly,\n        required: required,\n        autoFocus: autoFocus,\n        autoCapitalize: 'off',\n        autoComplete: 'off',\n        autoCorrect: 'off',\n        spellCheck: false,\n        'data-gramm': false\n      }), React.createElement('pre', _extends({\n        className: preClassName,\n        'aria-hidden': 'true',\n        style: _extends({}, styles.editor, styles.highlight, contentStyle)\n      }, typeof highlighted === 'string' ? {\n        dangerouslySetInnerHTML: {\n          __html: highlighted + '<br />'\n        }\n      } : {\n        children: highlighted\n      })), React.createElement('style', {\n        type: 'text/css',\n        dangerouslySetInnerHTML: {\n          __html: cssText\n        }\n      }));\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return {\n        history: this._history\n      };\n    },\n    set: function set(session) {\n      this._history = session.history;\n    }\n  }]);\n\n  return Editor;\n}(React.Component);\n\nEditor.defaultProps = {\n  tabSize: 2,\n  insertSpaces: true,\n  ignoreTabKey: false,\n  padding: 0\n};\nexports.default = Editor;\nvar styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden'\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent'\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none'\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word'\n  }\n};","map":{"version":3,"sources":["../src/index.js"],"names":["React","KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","navigator","isMacLike","className","cssText","Editor","Component","defaultProps","tabSize","insertSpaces","ignoreTabKey","padding","state","capture","_recordCurrentState","input","value","selectionStart","selectionEnd","_getLines","text","_recordChange","overwrite","stack","offset","count","extras","Math","timestamp","Date","last","re","previous","current","record","_updateInput","_applyEdits","_undoEdit","_redoEdit","_handleKeyDown","onKeyDown","e","tabCharacter","linesBeforeCaret","startLine","endLine","nextValue","i","line","startLineText","updatedSelection","hasSelection","textBeforeCaret","matches","indent","chars","_handleChange","_history","history","session","style","highlight","textareaId","textareaClassName","autoFocus","disabled","form","maxLength","minLength","name","placeholder","readOnly","required","onClick","onFocus","onBlur","onKeyUp","onValueChange","preClassName","rest","contentStyle","paddingTop","paddingRight","paddingBottom","paddingLeft","highlighted","styles","dangerouslySetInnerHTML","__html","children","container","position","textAlign","boxSizing","overflow","textarea","top","left","height","width","resize","color","MozOsxFontSmoothing","WebkitFontSmoothing","WebkitTextFillColor","pointerEvents","editor","margin","border","background","display","fontFamily","fontSize","fontStyle","fontVariantLigatures","fontWeight","letterSpacing","lineHeight","textIndent","textRendering","textTransform","whiteSpace","wordBreak","overflowWrap"],"mappings":"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","sourcesContent":["/* @flow */\n/* global global */\n\nimport * as React from 'react';\n\ntype Props = React.ElementConfig<'div'> & {\n  // Props for the component\n  value: string,\n  onValueChange: (value: string) => mixed,\n  highlight: (value: string) => string | React.Node,\n  tabSize: number,\n  insertSpaces: boolean,\n  ignoreTabKey: boolean,\n  padding: number | string,\n  style?: {},\n\n  // Props for the textarea\n  textareaId?: string,\n  textareaClassName?: string,\n  autoFocus?: boolean,\n  disabled?: boolean,\n  form?: string,\n  maxLength?: number,\n  minLength?: number,\n  name?: string,\n  placeholder?: string,\n  readOnly?: boolean,\n  required?: boolean,\n  onClick?: (e: MouseEvent) => mixed,\n  onFocus?: (e: FocusEvent) => mixed,\n  onBlur?: (e: FocusEvent) => mixed,\n  onKeyUp?: (e: KeyboardEvent) => mixed,\n  onKeyDown?: (e: KeyboardEvent) => mixed,\n\n  // Props for the hightlighted code’s pre element\n  preClassName?: string,\n};\n\ntype State = {\n  capture: boolean,\n};\n\ntype Record = {\n  value: string,\n  selectionStart: number,\n  selectionEnd: number,\n};\n\ntype History = {\n  stack: Array<Record & { timestamp: number }>,\n  offset: number,\n};\n\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nconst isMacLike =\n  'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nconst className = 'npm__react-simple-code-editor__textarea';\n\nconst cssText = /* CSS */ `\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\n\nexport default class Editor extends React.Component<Props, State> {\n  static defaultProps = {\n    tabSize: 2,\n    insertSpaces: true,\n    ignoreTabKey: false,\n    padding: 0,\n  };\n\n  state = {\n    capture: true,\n  };\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  _recordCurrentState = () => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Save current state of the input\n    const { value, selectionStart, selectionEnd } = input;\n\n    this._recordChange({\n      value,\n      selectionStart,\n      selectionEnd,\n    });\n  };\n\n  _getLines = (text: string, position: number) =>\n    text.substring(0, position).split('\\n');\n\n  _recordChange = (record: Record, overwrite?: boolean = false) => {\n    const { stack, offset } = this._history;\n\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      this._history.stack = stack.slice(0, offset + 1);\n\n      // Limit the number of operations to 100\n      const count = this._history.stack.length;\n\n      if (count > HISTORY_LIMIT) {\n        const extras = count - HISTORY_LIMIT;\n\n        this._history.stack = stack.slice(extras, count);\n        this._history.offset = Math.max(this._history.offset - extras, 0);\n      }\n    }\n\n    const timestamp = Date.now();\n\n    if (overwrite) {\n      const last = this._history.stack[this._history.offset];\n\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n\n        // Match the last word in the line\n        const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n        // Get the previous line\n        const previous = this._getLines(last.value, last.selectionStart)\n          .pop()\n          .match(re);\n\n        // Get the current line\n        const current = this._getLines(record.value, record.selectionStart)\n          .pop()\n          .match(re);\n\n        if (previous && current && current[1].startsWith(previous[1])) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          this._history.stack[this._history.offset] = { ...record, timestamp };\n\n          return;\n        }\n      }\n    }\n\n    // Add the new operation to the stack\n    this._history.stack.push({ ...record, timestamp });\n    this._history.offset++;\n  };\n\n  _updateInput = (record: Record) => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n\n    this.props.onValueChange(record.value);\n  };\n\n  _applyEdits = (record: Record) => {\n    // Save last selection state\n    const input = this._input;\n    const last = this._history.stack[this._history.offset];\n\n    if (last && input) {\n      this._history.stack[this._history.offset] = {\n        ...last,\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd,\n      };\n    }\n\n    // Save the changes\n    this._recordChange(record);\n    this._updateInput(record);\n  };\n\n  _undoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the previous edit\n    const record = stack[offset - 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.max(offset - 1, 0);\n    }\n  };\n\n  _redoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the next edit\n    const record = stack[offset + 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n\n  _handleKeyDown = (e: *) => {\n    const { tabSize, insertSpaces, ignoreTabKey, onKeyDown } = this.props;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n\n    if (e.keyCode === KEYCODE_ESCAPE) {\n      e.target.blur();\n    }\n\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n    if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n      // Prevent focus change\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        // Unindent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const nextValue = value\n          .split('\\n')\n          .map((line, i) => {\n            if (\n              i >= startLine &&\n              i <= endLine &&\n              line.startsWith(tabCharacter)\n            ) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          })\n          .join('\\n');\n\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length),\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        this._applyEdits({\n          value: value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            })\n            .join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: /\\S/.test(startLineText)\n            ? selectionStart + tabCharacter.length\n            : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n        });\n      } else {\n        const updatedSelection = selectionStart + tabCharacter.length;\n\n        this._applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_BACKSPACE) {\n      const hasSelection = selectionStart !== selectionEnd;\n      const textBeforeCaret = value.substring(0, selectionStart);\n\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n\n        const updatedSelection = selectionStart - tabCharacter.length;\n\n        this._applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, selectionStart - tabCharacter.length) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_ENTER) {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        const line = this._getLines(value, selectionStart).pop();\n        const matches = line.match(/^\\s+/);\n\n        if (matches && matches[0]) {\n          e.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = '\\n' + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          this._applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      }\n    } else if (\n      e.keyCode === KEYCODE_PARENS ||\n      e.keyCode === KEYCODE_BRACKETS ||\n      e.keyCode === KEYCODE_QUOTE ||\n      e.keyCode === KEYCODE_BACK_QUOTE\n    ) {\n      let chars;\n\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = ['(', ')'];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = ['{', '}'];\n        } else {\n          chars = ['[', ']'];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = ['`', '`'];\n      }\n\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n\n        this._applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2,\n        });\n      }\n    } else if (\n      (isMacLike\n        ? // Trigger undo with ⌘+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z\n        : // Trigger undo with Ctrl+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n      !e.shiftKey &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._undoEdit();\n    } else if (\n      (isMacLike\n        ? // Trigger redo with ⌘+Shift+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n        : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._redoEdit();\n    } else if (\n      e.keyCode === KEYCODE_M &&\n      e.ctrlKey &&\n      (isMacLike ? e.shiftKey : true)\n    ) {\n      e.preventDefault();\n\n      // Toggle capturing tab key so users can focus away\n      this.setState(state => ({\n        capture: !state.capture,\n      }));\n    }\n  };\n\n  _handleChange = (e: *) => {\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    this._recordChange(\n      {\n        value,\n        selectionStart,\n        selectionEnd,\n      },\n      true\n    );\n\n    this.props.onValueChange(value);\n  };\n\n  _history: History = {\n    stack: [],\n    offset: -1,\n  };\n\n  _input: ?HTMLTextAreaElement;\n\n  get session() {\n    return {\n      history: this._history,\n    };\n  }\n\n  set session(session: { history: History }) {\n    this._history = session.history;\n  }\n\n  render() {\n    const {\n      value,\n      style,\n      padding,\n      highlight,\n      textareaId,\n      textareaClassName,\n      autoFocus,\n      disabled,\n      form,\n      maxLength,\n      minLength,\n      name,\n      placeholder,\n      readOnly,\n      required,\n      onClick,\n      onFocus,\n      onBlur,\n      onKeyUp,\n      /* eslint-disable no-unused-vars */\n      onKeyDown,\n      onValueChange,\n      tabSize,\n      insertSpaces,\n      ignoreTabKey,\n      /* eslint-enable no-unused-vars */\n      preClassName,\n      ...rest\n    } = this.props;\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding,\n    };\n\n    const highlighted = highlight(value);\n\n    return (\n      <div {...rest} style={{ ...styles.container, ...style }}>\n        <textarea\n          ref={c => (this._input = c)}\n          style={{\n            ...styles.editor,\n            ...styles.textarea,\n            ...contentStyle,\n          }}\n          className={\n            className + (textareaClassName ? ` ${textareaClassName}` : '')\n          }\n          id={textareaId}\n          value={value}\n          onChange={this._handleChange}\n          onKeyDown={this._handleKeyDown}\n          onClick={onClick}\n          onKeyUp={onKeyUp}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          disabled={disabled}\n          form={form}\n          maxLength={maxLength}\n          minLength={minLength}\n          name={name}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          required={required}\n          autoFocus={autoFocus}\n          autoCapitalize=\"off\"\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          spellCheck={false}\n          data-gramm={false}\n        />\n        <pre\n          className={preClassName}\n          aria-hidden=\"true\"\n          style={{ ...styles.editor, ...styles.highlight, ...contentStyle }}\n          {...(typeof highlighted === 'string'\n            ? { dangerouslySetInnerHTML: { __html: highlighted + '<br />' } }\n            : { children: highlighted })}\n        />\n        {/* eslint-disable-next-line react/no-danger */}\n        <style type=\"text/css\" dangerouslySetInnerHTML={{ __html: cssText }} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden',\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent',\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none',\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word',\n  },\n};\n"]},"metadata":{},"sourceType":"script"}